{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar React = _interopRequireWildcard(_react);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* global global */\n\n\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nvar isMacLike = 'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\nvar className = 'npm__react-simple-code-editor__textarea';\nvar cssText =\n/* CSS */\n'\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.' + className + ':empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn\\'t support \\'-webkit-text-fill-color\\'\\n    * So we use \\'color: transparent\\' to make the text transparent on IE\\n    * Unlike other browsers, it doesn\\'t affect caret color in IE\\n    */\\n  .' + className + ' {\\n    color: transparent !important;\\n  }\\n\\n  .' + className + '::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n';\n\nvar Editor = function (_React$Component) {\n  _inherits(Editor, _React$Component);\n\n  function Editor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Editor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      capture: true\n    }, _this._recordCurrentState = function () {\n      var input = _this._input;\n      if (!input) return; // Save current state of the input\n\n      var value = input.value,\n          selectionStart = input.selectionStart,\n          selectionEnd = input.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      });\n    }, _this._getLines = function (text, position) {\n      return text.substring(0, position).split('\\n');\n    }, _this._recordChange = function (record) {\n      var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var _this$_history = _this._history,\n          stack = _this$_history.stack,\n          offset = _this$_history.offset;\n\n      if (stack.length && offset > -1) {\n        // When something updates, drop the redo operations\n        _this._history.stack = stack.slice(0, offset + 1); // Limit the number of operations to 100\n\n        var count = _this._history.stack.length;\n\n        if (count > HISTORY_LIMIT) {\n          var extras = count - HISTORY_LIMIT;\n          _this._history.stack = stack.slice(extras, count);\n          _this._history.offset = Math.max(_this._history.offset - extras, 0);\n        }\n      }\n\n      var timestamp = Date.now();\n\n      if (overwrite) {\n        var last = _this._history.stack[_this._history.offset];\n\n        if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n          // A previous entry exists and was in short interval\n          // Match the last word in the line\n          var re = /[^a-z0-9]([a-z0-9]+)$/i; // Get the previous line\n\n          var previous = _this._getLines(last.value, last.selectionStart).pop().match(re); // Get the current line\n\n\n          var current = _this._getLines(record.value, record.selectionStart).pop().match(re);\n\n          if (previous && current && current[1].startsWith(previous[1])) {\n            // The last word of the previous line and current line match\n            // Overwrite previous entry so that undo will remove whole word\n            _this._history.stack[_this._history.offset] = _extends({}, record, {\n              timestamp: timestamp\n            });\n            return;\n          }\n        }\n      } // Add the new operation to the stack\n\n\n      _this._history.stack.push(_extends({}, record, {\n        timestamp: timestamp\n      }));\n\n      _this._history.offset++;\n    }, _this._updateInput = function (record) {\n      var input = _this._input;\n      if (!input) return; // Update values and selection state\n\n      input.value = record.value;\n      input.selectionStart = record.selectionStart;\n      input.selectionEnd = record.selectionEnd;\n\n      _this.props.onValueChange(record.value);\n    }, _this._applyEdits = function (record) {\n      // Save last selection state\n      var input = _this._input;\n      var last = _this._history.stack[_this._history.offset];\n\n      if (last && input) {\n        _this._history.stack[_this._history.offset] = _extends({}, last, {\n          selectionStart: input.selectionStart,\n          selectionEnd: input.selectionEnd\n        });\n      } // Save the changes\n\n\n      _this._recordChange(record);\n\n      _this._updateInput(record);\n    }, _this._undoEdit = function () {\n      var _this$_history2 = _this._history,\n          stack = _this$_history2.stack,\n          offset = _this$_history2.offset; // Get the previous edit\n\n      var record = stack[offset - 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.max(offset - 1, 0);\n      }\n    }, _this._redoEdit = function () {\n      var _this$_history3 = _this._history,\n          stack = _this$_history3.stack,\n          offset = _this$_history3.offset; // Get the next edit\n\n      var record = stack[offset + 1];\n\n      if (record) {\n        // Apply the changes and update the offset\n        _this._updateInput(record);\n\n        _this._history.offset = Math.min(offset + 1, stack.length - 1);\n      }\n    }, _this._handleKeyDown = function (e) {\n      var _this$props = _this.props,\n          tabSize = _this$props.tabSize,\n          insertSpaces = _this$props.insertSpaces,\n          ignoreTabKey = _this$props.ignoreTabKey,\n          onKeyDown = _this$props.onKeyDown;\n\n      if (onKeyDown) {\n        onKeyDown(e);\n\n        if (e.defaultPrevented) {\n          return;\n        }\n      }\n\n      if (e.keyCode === KEYCODE_ESCAPE) {\n        e.target.blur();\n      }\n\n      var _e$target = e.target,\n          value = _e$target.value,\n          selectionStart = _e$target.selectionStart,\n          selectionEnd = _e$target.selectionEnd;\n      var tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n      if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && _this.state.capture) {\n        // Prevent focus change\n        e.preventDefault();\n\n        if (e.shiftKey) {\n          // Unindent selected lines\n          var linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var startLine = linesBeforeCaret.length - 1;\n          var endLine = _this._getLines(value, selectionEnd).length - 1;\n          var nextValue = value.split('\\n').map(function (line, i) {\n            if (i >= startLine && i <= endLine && line.startsWith(tabCharacter)) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          }).join('\\n');\n\n          if (value !== nextValue) {\n            var startLineText = linesBeforeCaret[startLine];\n\n            _this._applyEdits({\n              value: nextValue,\n              // Move the start cursor if first line in selection was modified\n              // It was modified only if it started with a tab\n              selectionStart: startLineText.startsWith(tabCharacter) ? selectionStart - tabCharacter.length : selectionStart,\n              // Move the end cursor by total number of characters removed\n              selectionEnd: selectionEnd - (value.length - nextValue.length)\n            });\n          }\n        } else if (selectionStart !== selectionEnd) {\n          // Indent selected lines\n          var _linesBeforeCaret = _this._getLines(value, selectionStart);\n\n          var _startLine = _linesBeforeCaret.length - 1;\n\n          var _endLine = _this._getLines(value, selectionEnd).length - 1;\n\n          var _startLineText = _linesBeforeCaret[_startLine];\n\n          _this._applyEdits({\n            value: value.split('\\n').map(function (line, i) {\n              if (i >= _startLine && i <= _endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            }).join('\\n'),\n            // Move the start cursor by number of characters added in first line of selection\n            // Don't move it if it there was no text before cursor\n            selectionStart: /\\S/.test(_startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n            // Move the end cursor by total number of characters added\n            selectionEnd: selectionEnd + tabCharacter.length * (_endLine - _startLine + 1)\n          });\n        } else {\n          var updatedSelection = selectionStart + tabCharacter.length;\n\n          _this._applyEdits({\n            // Insert tab character at caret\n            value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_BACKSPACE) {\n        var hasSelection = selectionStart !== selectionEnd;\n        var textBeforeCaret = value.substring(0, selectionStart);\n\n        if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n          // Prevent default delete behaviour\n          e.preventDefault();\n\n          var _updatedSelection = selectionStart - tabCharacter.length;\n\n          _this._applyEdits({\n            // Remove tab character at caret\n            value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: _updatedSelection,\n            selectionEnd: _updatedSelection\n          });\n        }\n      } else if (e.keyCode === KEYCODE_ENTER) {\n        // Ignore selections\n        if (selectionStart === selectionEnd) {\n          // Get the current line\n          var line = _this._getLines(value, selectionStart).pop();\n\n          var matches = line.match(/^\\s+/);\n\n          if (matches && matches[0]) {\n            e.preventDefault(); // Preserve indentation on inserting a new line\n\n            var indent = '\\n' + matches[0];\n\n            var _updatedSelection2 = selectionStart + indent.length;\n\n            _this._applyEdits({\n              // Insert indentation character at caret\n              value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n              // Update caret position\n              selectionStart: _updatedSelection2,\n              selectionEnd: _updatedSelection2\n            });\n          }\n        }\n      } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n        var chars = void 0;\n\n        if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n          chars = ['(', ')'];\n        } else if (e.keyCode === KEYCODE_BRACKETS) {\n          if (e.shiftKey) {\n            chars = ['{', '}'];\n          } else {\n            chars = ['[', ']'];\n          }\n        } else if (e.keyCode === KEYCODE_QUOTE) {\n          if (e.shiftKey) {\n            chars = ['\"', '\"'];\n          } else {\n            chars = [\"'\", \"'\"];\n          }\n        } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n          chars = ['`', '`'];\n        } // If text is selected, wrap them in the characters\n\n\n        if (selectionStart !== selectionEnd && chars) {\n          e.preventDefault();\n\n          _this._applyEdits({\n            value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd + 2\n          });\n        }\n      } else if ((isMacLike ? // Trigger undo with ⌘+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z : // Trigger undo with Ctrl+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n        e.preventDefault();\n\n        _this._undoEdit();\n      } else if ((isMacLike ? // Trigger redo with ⌘+Shift+Z on Mac\n      e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? // Trigger redo with Ctrl+Y on Windows\n      e.ctrlKey && e.keyCode === KEYCODE_Y : // Trigger redo with Ctrl+Shift+Z on other platforms\n      e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n        e.preventDefault();\n\n        _this._redoEdit();\n      } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n        e.preventDefault(); // Toggle capturing tab key so users can focus away\n\n        _this.setState(function (state) {\n          return {\n            capture: !state.capture\n          };\n        });\n      }\n    }, _this._handleChange = function (e) {\n      var _e$target2 = e.target,\n          value = _e$target2.value,\n          selectionStart = _e$target2.selectionStart,\n          selectionEnd = _e$target2.selectionEnd;\n\n      _this._recordChange({\n        value: value,\n        selectionStart: selectionStart,\n        selectionEnd: selectionEnd\n      }, true);\n\n      _this.props.onValueChange(value);\n    }, _this._history = {\n      stack: [],\n      offset: -1\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Editor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._recordCurrentState();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          value = _props.value,\n          style = _props.style,\n          padding = _props.padding,\n          highlight = _props.highlight,\n          textareaId = _props.textareaId,\n          textareaClassName = _props.textareaClassName,\n          autoFocus = _props.autoFocus,\n          disabled = _props.disabled,\n          form = _props.form,\n          maxLength = _props.maxLength,\n          minLength = _props.minLength,\n          name = _props.name,\n          placeholder = _props.placeholder,\n          readOnly = _props.readOnly,\n          required = _props.required,\n          onClick = _props.onClick,\n          onFocus = _props.onFocus,\n          onBlur = _props.onBlur,\n          onKeyUp = _props.onKeyUp,\n          onKeyDown = _props.onKeyDown,\n          onValueChange = _props.onValueChange,\n          tabSize = _props.tabSize,\n          insertSpaces = _props.insertSpaces,\n          ignoreTabKey = _props.ignoreTabKey,\n          preClassName = _props.preClassName,\n          rest = _objectWithoutProperties(_props, ['value', 'style', 'padding', 'highlight', 'textareaId', 'textareaClassName', 'autoFocus', 'disabled', 'form', 'maxLength', 'minLength', 'name', 'placeholder', 'readOnly', 'required', 'onClick', 'onFocus', 'onBlur', 'onKeyUp', 'onKeyDown', 'onValueChange', 'tabSize', 'insertSpaces', 'ignoreTabKey', 'preClassName']);\n\n      var contentStyle = {\n        paddingTop: padding,\n        paddingRight: padding,\n        paddingBottom: padding,\n        paddingLeft: padding\n      };\n      var highlighted = highlight(value);\n      return React.createElement('div', _extends({}, rest, {\n        style: _extends({}, styles.container, style)\n      }), React.createElement('textarea', {\n        ref: function ref(c) {\n          return _this2._input = c;\n        },\n        style: _extends({}, styles.editor, styles.textarea, contentStyle),\n        className: className + (textareaClassName ? ' ' + textareaClassName : ''),\n        id: textareaId,\n        value: value,\n        onChange: this._handleChange,\n        onKeyDown: this._handleKeyDown,\n        onClick: onClick,\n        onKeyUp: onKeyUp,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        disabled: disabled,\n        form: form,\n        maxLength: maxLength,\n        minLength: minLength,\n        name: name,\n        placeholder: placeholder,\n        readOnly: readOnly,\n        required: required,\n        autoFocus: autoFocus,\n        autoCapitalize: 'off',\n        autoComplete: 'off',\n        autoCorrect: 'off',\n        spellCheck: false,\n        'data-gramm': false\n      }), React.createElement('pre', _extends({\n        className: preClassName,\n        'aria-hidden': 'true',\n        style: _extends({}, styles.editor, styles.highlight, contentStyle)\n      }, typeof highlighted === 'string' ? {\n        dangerouslySetInnerHTML: {\n          __html: highlighted + '<br />'\n        }\n      } : {\n        children: highlighted\n      })), React.createElement('style', {\n        type: 'text/css',\n        dangerouslySetInnerHTML: {\n          __html: cssText\n        }\n      }));\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return {\n        history: this._history\n      };\n    },\n    set: function set(session) {\n      this._history = session.history;\n    }\n  }]);\n\n  return Editor;\n}(React.Component);\n\nEditor.defaultProps = {\n  tabSize: 2,\n  insertSpaces: true,\n  ignoreTabKey: false,\n  padding: 0\n};\nexports.default = Editor;\nvar styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden'\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent'\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none'\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word'\n  }\n};","map":{"version":3,"sources":["../src/index.js"],"names":["React","KEYCODE_ENTER","KEYCODE_TAB","KEYCODE_BACKSPACE","KEYCODE_Y","KEYCODE_Z","KEYCODE_M","KEYCODE_PARENS","KEYCODE_BRACKETS","KEYCODE_QUOTE","KEYCODE_BACK_QUOTE","KEYCODE_ESCAPE","HISTORY_LIMIT","HISTORY_TIME_GAP","isWindows","navigator","isMacLike","className","cssText","Editor","Component","defaultProps","tabSize","insertSpaces","ignoreTabKey","padding","state","capture","_recordCurrentState","input","value","selectionStart","selectionEnd","_getLines","text","_recordChange","overwrite","stack","offset","count","extras","Math","timestamp","Date","last","re","previous","current","record","_updateInput","_applyEdits","_undoEdit","_redoEdit","_handleKeyDown","onKeyDown","e","tabCharacter","linesBeforeCaret","startLine","endLine","nextValue","i","line","startLineText","updatedSelection","hasSelection","textBeforeCaret","matches","indent","chars","_handleChange","_history","history","session","style","highlight","textareaId","textareaClassName","autoFocus","disabled","form","maxLength","minLength","name","placeholder","readOnly","required","onClick","onFocus","onBlur","onKeyUp","onValueChange","preClassName","rest","contentStyle","paddingTop","paddingRight","paddingBottom","paddingLeft","highlighted","styles","dangerouslySetInnerHTML","__html","children","container","position","textAlign","boxSizing","overflow","textarea","top","left","height","width","resize","color","MozOsxFontSmoothing","WebkitFontSmoothing","WebkitTextFillColor","pointerEvents","editor","margin","border","background","display","fontFamily","fontSize","fontStyle","fontVariantLigatures","fontWeight","letterSpacing","lineHeight","textIndent","textRendering","textTransform","whiteSpace","wordBreak","overflowWrap"],"mappings":"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","sourcesContent":["/* @flow */\n/* global global */\n\nimport * as React from 'react';\n\ntype Props = React.ElementConfig<'div'> & {\n  // Props for the component\n  value: string,\n  onValueChange: (value: string) => mixed,\n  highlight: (value: string) => string | React.Node,\n  tabSize: number,\n  insertSpaces: boolean,\n  ignoreTabKey: boolean,\n  padding: number | string,\n  style?: {},\n\n  // Props for the textarea\n  textareaId?: string,\n  textareaClassName?: string,\n  autoFocus?: boolean,\n  disabled?: boolean,\n  form?: string,\n  maxLength?: number,\n  minLength?: number,\n  name?: string,\n  placeholder?: string,\n  readOnly?: boolean,\n  required?: boolean,\n  onClick?: (e: MouseEvent) => mixed,\n  onFocus?: (e: FocusEvent) => mixed,\n  onBlur?: (e: FocusEvent) => mixed,\n  onKeyUp?: (e: KeyboardEvent) => mixed,\n  onKeyDown?: (e: KeyboardEvent) => mixed,\n\n  // Props for the hightlighted code’s pre element\n  preClassName?: string,\n};\n\ntype State = {\n  capture: boolean,\n};\n\ntype Record = {\n  value: string,\n  selectionStart: number,\n  selectionEnd: number,\n};\n\ntype History = {\n  stack: Array<Record & { timestamp: number }>,\n  offset: number,\n};\n\nconst KEYCODE_ENTER = 13;\nconst KEYCODE_TAB = 9;\nconst KEYCODE_BACKSPACE = 8;\nconst KEYCODE_Y = 89;\nconst KEYCODE_Z = 90;\nconst KEYCODE_M = 77;\nconst KEYCODE_PARENS = 57;\nconst KEYCODE_BRACKETS = 219;\nconst KEYCODE_QUOTE = 222;\nconst KEYCODE_BACK_QUOTE = 192;\nconst KEYCODE_ESCAPE = 27;\n\nconst HISTORY_LIMIT = 100;\nconst HISTORY_TIME_GAP = 3000;\n\nconst isWindows = 'navigator' in global && /Win/i.test(navigator.platform);\nconst isMacLike =\n  'navigator' in global && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n\nconst className = 'npm__react-simple-code-editor__textarea';\n\nconst cssText = /* CSS */ `\n/**\n * Reset the text fill color so that placeholder is visible\n */\n.${className}:empty {\n  -webkit-text-fill-color: inherit !important;\n}\n\n/**\n * Hack to apply on some CSS on IE10 and IE11\n */\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\n  /**\n    * IE doesn't support '-webkit-text-fill-color'\n    * So we use 'color: transparent' to make the text transparent on IE\n    * Unlike other browsers, it doesn't affect caret color in IE\n    */\n  .${className} {\n    color: transparent !important;\n  }\n\n  .${className}::selection {\n    background-color: #accef7 !important;\n    color: transparent !important;\n  }\n}\n`;\n\nexport default class Editor extends React.Component<Props, State> {\n  static defaultProps = {\n    tabSize: 2,\n    insertSpaces: true,\n    ignoreTabKey: false,\n    padding: 0,\n  };\n\n  state = {\n    capture: true,\n  };\n\n  componentDidMount() {\n    this._recordCurrentState();\n  }\n\n  _recordCurrentState = () => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Save current state of the input\n    const { value, selectionStart, selectionEnd } = input;\n\n    this._recordChange({\n      value,\n      selectionStart,\n      selectionEnd,\n    });\n  };\n\n  _getLines = (text: string, position: number) =>\n    text.substring(0, position).split('\\n');\n\n  _recordChange = (record: Record, overwrite?: boolean = false) => {\n    const { stack, offset } = this._history;\n\n    if (stack.length && offset > -1) {\n      // When something updates, drop the redo operations\n      this._history.stack = stack.slice(0, offset + 1);\n\n      // Limit the number of operations to 100\n      const count = this._history.stack.length;\n\n      if (count > HISTORY_LIMIT) {\n        const extras = count - HISTORY_LIMIT;\n\n        this._history.stack = stack.slice(extras, count);\n        this._history.offset = Math.max(this._history.offset - extras, 0);\n      }\n    }\n\n    const timestamp = Date.now();\n\n    if (overwrite) {\n      const last = this._history.stack[this._history.offset];\n\n      if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n        // A previous entry exists and was in short interval\n\n        // Match the last word in the line\n        const re = /[^a-z0-9]([a-z0-9]+)$/i;\n\n        // Get the previous line\n        const previous = this._getLines(last.value, last.selectionStart)\n          .pop()\n          .match(re);\n\n        // Get the current line\n        const current = this._getLines(record.value, record.selectionStart)\n          .pop()\n          .match(re);\n\n        if (previous && current && current[1].startsWith(previous[1])) {\n          // The last word of the previous line and current line match\n          // Overwrite previous entry so that undo will remove whole word\n          this._history.stack[this._history.offset] = { ...record, timestamp };\n\n          return;\n        }\n      }\n    }\n\n    // Add the new operation to the stack\n    this._history.stack.push({ ...record, timestamp });\n    this._history.offset++;\n  };\n\n  _updateInput = (record: Record) => {\n    const input = this._input;\n\n    if (!input) return;\n\n    // Update values and selection state\n    input.value = record.value;\n    input.selectionStart = record.selectionStart;\n    input.selectionEnd = record.selectionEnd;\n\n    this.props.onValueChange(record.value);\n  };\n\n  _applyEdits = (record: Record) => {\n    // Save last selection state\n    const input = this._input;\n    const last = this._history.stack[this._history.offset];\n\n    if (last && input) {\n      this._history.stack[this._history.offset] = {\n        ...last,\n        selectionStart: input.selectionStart,\n        selectionEnd: input.selectionEnd,\n      };\n    }\n\n    // Save the changes\n    this._recordChange(record);\n    this._updateInput(record);\n  };\n\n  _undoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the previous edit\n    const record = stack[offset - 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.max(offset - 1, 0);\n    }\n  };\n\n  _redoEdit = () => {\n    const { stack, offset } = this._history;\n\n    // Get the next edit\n    const record = stack[offset + 1];\n\n    if (record) {\n      // Apply the changes and update the offset\n      this._updateInput(record);\n      this._history.offset = Math.min(offset + 1, stack.length - 1);\n    }\n  };\n\n  _handleKeyDown = (e: *) => {\n    const { tabSize, insertSpaces, ignoreTabKey, onKeyDown } = this.props;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n\n      if (e.defaultPrevented) {\n        return;\n      }\n    }\n\n    if (e.keyCode === KEYCODE_ESCAPE) {\n      e.target.blur();\n    }\n\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    const tabCharacter = (insertSpaces ? ' ' : '\\t').repeat(tabSize);\n\n    if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && this.state.capture) {\n      // Prevent focus change\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        // Unindent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const nextValue = value\n          .split('\\n')\n          .map((line, i) => {\n            if (\n              i >= startLine &&\n              i <= endLine &&\n              line.startsWith(tabCharacter)\n            ) {\n              return line.substring(tabCharacter.length);\n            }\n\n            return line;\n          })\n          .join('\\n');\n\n        if (value !== nextValue) {\n          const startLineText = linesBeforeCaret[startLine];\n\n          this._applyEdits({\n            value: nextValue,\n            // Move the start cursor if first line in selection was modified\n            // It was modified only if it started with a tab\n            selectionStart: startLineText.startsWith(tabCharacter)\n              ? selectionStart - tabCharacter.length\n              : selectionStart,\n            // Move the end cursor by total number of characters removed\n            selectionEnd: selectionEnd - (value.length - nextValue.length),\n          });\n        }\n      } else if (selectionStart !== selectionEnd) {\n        // Indent selected lines\n        const linesBeforeCaret = this._getLines(value, selectionStart);\n        const startLine = linesBeforeCaret.length - 1;\n        const endLine = this._getLines(value, selectionEnd).length - 1;\n        const startLineText = linesBeforeCaret[startLine];\n\n        this._applyEdits({\n          value: value\n            .split('\\n')\n            .map((line, i) => {\n              if (i >= startLine && i <= endLine) {\n                return tabCharacter + line;\n              }\n\n              return line;\n            })\n            .join('\\n'),\n          // Move the start cursor by number of characters added in first line of selection\n          // Don't move it if it there was no text before cursor\n          selectionStart: /\\S/.test(startLineText)\n            ? selectionStart + tabCharacter.length\n            : selectionStart,\n          // Move the end cursor by total number of characters added\n          selectionEnd:\n            selectionEnd + tabCharacter.length * (endLine - startLine + 1),\n        });\n      } else {\n        const updatedSelection = selectionStart + tabCharacter.length;\n\n        this._applyEdits({\n          // Insert tab character at caret\n          value:\n            value.substring(0, selectionStart) +\n            tabCharacter +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_BACKSPACE) {\n      const hasSelection = selectionStart !== selectionEnd;\n      const textBeforeCaret = value.substring(0, selectionStart);\n\n      if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n        // Prevent default delete behaviour\n        e.preventDefault();\n\n        const updatedSelection = selectionStart - tabCharacter.length;\n\n        this._applyEdits({\n          // Remove tab character at caret\n          value:\n            value.substring(0, selectionStart - tabCharacter.length) +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart: updatedSelection,\n          selectionEnd: updatedSelection,\n        });\n      }\n    } else if (e.keyCode === KEYCODE_ENTER) {\n      // Ignore selections\n      if (selectionStart === selectionEnd) {\n        // Get the current line\n        const line = this._getLines(value, selectionStart).pop();\n        const matches = line.match(/^\\s+/);\n\n        if (matches && matches[0]) {\n          e.preventDefault();\n\n          // Preserve indentation on inserting a new line\n          const indent = '\\n' + matches[0];\n          const updatedSelection = selectionStart + indent.length;\n\n          this._applyEdits({\n            // Insert indentation character at caret\n            value:\n              value.substring(0, selectionStart) +\n              indent +\n              value.substring(selectionEnd),\n            // Update caret position\n            selectionStart: updatedSelection,\n            selectionEnd: updatedSelection,\n          });\n        }\n      }\n    } else if (\n      e.keyCode === KEYCODE_PARENS ||\n      e.keyCode === KEYCODE_BRACKETS ||\n      e.keyCode === KEYCODE_QUOTE ||\n      e.keyCode === KEYCODE_BACK_QUOTE\n    ) {\n      let chars;\n\n      if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n        chars = ['(', ')'];\n      } else if (e.keyCode === KEYCODE_BRACKETS) {\n        if (e.shiftKey) {\n          chars = ['{', '}'];\n        } else {\n          chars = ['[', ']'];\n        }\n      } else if (e.keyCode === KEYCODE_QUOTE) {\n        if (e.shiftKey) {\n          chars = ['\"', '\"'];\n        } else {\n          chars = [\"'\", \"'\"];\n        }\n      } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n        chars = ['`', '`'];\n      }\n\n      // If text is selected, wrap them in the characters\n      if (selectionStart !== selectionEnd && chars) {\n        e.preventDefault();\n\n        this._applyEdits({\n          value:\n            value.substring(0, selectionStart) +\n            chars[0] +\n            value.substring(selectionStart, selectionEnd) +\n            chars[1] +\n            value.substring(selectionEnd),\n          // Update caret position\n          selectionStart,\n          selectionEnd: selectionEnd + 2,\n        });\n      }\n    } else if (\n      (isMacLike\n        ? // Trigger undo with ⌘+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z\n        : // Trigger undo with Ctrl+Z on other platforms\n          e.ctrlKey && e.keyCode === KEYCODE_Z) &&\n      !e.shiftKey &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._undoEdit();\n    } else if (\n      (isMacLike\n        ? // Trigger redo with ⌘+Shift+Z on Mac\n          e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey\n        : isWindows\n          ? // Trigger redo with Ctrl+Y on Windows\n            e.ctrlKey && e.keyCode === KEYCODE_Y\n          : // Trigger redo with Ctrl+Shift+Z on other platforms\n            e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) &&\n      !e.altKey\n    ) {\n      e.preventDefault();\n\n      this._redoEdit();\n    } else if (\n      e.keyCode === KEYCODE_M &&\n      e.ctrlKey &&\n      (isMacLike ? e.shiftKey : true)\n    ) {\n      e.preventDefault();\n\n      // Toggle capturing tab key so users can focus away\n      this.setState(state => ({\n        capture: !state.capture,\n      }));\n    }\n  };\n\n  _handleChange = (e: *) => {\n    const { value, selectionStart, selectionEnd } = e.target;\n\n    this._recordChange(\n      {\n        value,\n        selectionStart,\n        selectionEnd,\n      },\n      true\n    );\n\n    this.props.onValueChange(value);\n  };\n\n  _history: History = {\n    stack: [],\n    offset: -1,\n  };\n\n  _input: ?HTMLTextAreaElement;\n\n  get session() {\n    return {\n      history: this._history,\n    };\n  }\n\n  set session(session: { history: History }) {\n    this._history = session.history;\n  }\n\n  render() {\n    const {\n      value,\n      style,\n      padding,\n      highlight,\n      textareaId,\n      textareaClassName,\n      autoFocus,\n      disabled,\n      form,\n      maxLength,\n      minLength,\n      name,\n      placeholder,\n      readOnly,\n      required,\n      onClick,\n      onFocus,\n      onBlur,\n      onKeyUp,\n      /* eslint-disable no-unused-vars */\n      onKeyDown,\n      onValueChange,\n      tabSize,\n      insertSpaces,\n      ignoreTabKey,\n      /* eslint-enable no-unused-vars */\n      preClassName,\n      ...rest\n    } = this.props;\n\n    const contentStyle = {\n      paddingTop: padding,\n      paddingRight: padding,\n      paddingBottom: padding,\n      paddingLeft: padding,\n    };\n\n    const highlighted = highlight(value);\n\n    return (\n      <div {...rest} style={{ ...styles.container, ...style }}>\n        <textarea\n          ref={c => (this._input = c)}\n          style={{\n            ...styles.editor,\n            ...styles.textarea,\n            ...contentStyle,\n          }}\n          className={\n            className + (textareaClassName ? ` ${textareaClassName}` : '')\n          }\n          id={textareaId}\n          value={value}\n          onChange={this._handleChange}\n          onKeyDown={this._handleKeyDown}\n          onClick={onClick}\n          onKeyUp={onKeyUp}\n          onFocus={onFocus}\n          onBlur={onBlur}\n          disabled={disabled}\n          form={form}\n          maxLength={maxLength}\n          minLength={minLength}\n          name={name}\n          placeholder={placeholder}\n          readOnly={readOnly}\n          required={required}\n          autoFocus={autoFocus}\n          autoCapitalize=\"off\"\n          autoComplete=\"off\"\n          autoCorrect=\"off\"\n          spellCheck={false}\n          data-gramm={false}\n        />\n        <pre\n          className={preClassName}\n          aria-hidden=\"true\"\n          style={{ ...styles.editor, ...styles.highlight, ...contentStyle }}\n          {...(typeof highlighted === 'string'\n            ? { dangerouslySetInnerHTML: { __html: highlighted + '<br />' } }\n            : { children: highlighted })}\n        />\n        {/* eslint-disable-next-line react/no-danger */}\n        <style type=\"text/css\" dangerouslySetInnerHTML={{ __html: cssText }} />\n      </div>\n    );\n  }\n}\n\nconst styles = {\n  container: {\n    position: 'relative',\n    textAlign: 'left',\n    boxSizing: 'border-box',\n    padding: 0,\n    overflow: 'hidden',\n  },\n  textarea: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    height: '100%',\n    width: '100%',\n    resize: 'none',\n    color: 'inherit',\n    overflow: 'hidden',\n    MozOsxFontSmoothing: 'grayscale',\n    WebkitFontSmoothing: 'antialiased',\n    WebkitTextFillColor: 'transparent',\n  },\n  highlight: {\n    position: 'relative',\n    pointerEvents: 'none',\n  },\n  editor: {\n    margin: 0,\n    border: 0,\n    background: 'none',\n    boxSizing: 'inherit',\n    display: 'inherit',\n    fontFamily: 'inherit',\n    fontSize: 'inherit',\n    fontStyle: 'inherit',\n    fontVariantLigatures: 'inherit',\n    fontWeight: 'inherit',\n    letterSpacing: 'inherit',\n    lineHeight: 'inherit',\n    tabSize: 'inherit',\n    textIndent: 'inherit',\n    textRendering: 'inherit',\n    textTransform: 'inherit',\n    whiteSpace: 'pre-wrap',\n    wordBreak: 'keep-all',\n    overflowWrap: 'break-word',\n  },\n};\n"]},"metadata":{},"sourceType":"script"}